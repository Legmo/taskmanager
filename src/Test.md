#Заметки по web-разработке#

##JS##
<details>
  <summary>Обработчики событий</summary>
   <p>функции, которые позволяют обрабатывать события (например щелчок мыши) и реагировать на них</p>
</details>

<details>
  <summary>Объекты {} и массивы []</summary>
		- { width: 300,  height: 200, } - объект. Данные в формате ключ-значение.
		- [ 300, 200, ]                 - массив. Для хранения пронумерованных значений. 
			Обычно используются для хранения УПОРЯДОЧЕННЫХ коллекций данных, например – списка товаров на странице, студентов в группе и т.п. 
			Элементы должны идти подряд, иначе будет так:
			    var a = [];
			    a[0] = 0;
			    a[5] = 5;
			    alert( a ); // 0,,,,,5
</details>

<details>
  <summary>Callback - сами не вызываем функцию. Отдаём её кому-то, и он вызывает, когда сочтёт нужным. В одну функцию передаём другую</summary>
		Например: 
			<button onClik={function}>txt</button> 
			когда произойдёт событие onClick, кнопка вызовет эту функцию
		
		Неправильно: 
			<button onClik={function()}>txt</button> 
			функция вызывается.

		При вызове callback может нарушиться контекст вызова this. 
		Т.е. отвалиться привязка this к родительскому объекту.
		  <App
		    addQuote={store.addQuote} //нет скобок после addQuote - мы не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо. От своего имени
		  />
		В таком случае, при создании callback надо сделать привязку контекста - bind
		  <App
		    addQuote={store.addQuote.bind(store)} 
		  />

	- bind - позволяет привязать контекст к функции. Важно при callback. 
		При вызове callback может нарушиться контекст вызова this. Т.е. отвалиться привязка this  к родительскому объекту.
		  <App
		    addQuote={store.addQuote} //нет скобок после addQuote - мы не вызываем функцию сейчас, а передаём кому-то. И он вызовет, когда будет надо. От своего имени
		  />
		В таком случае, при создании callback надо сделать привязку контекста - bind
		  <App
		    addQuote={store.addQuote.bind(store)} 
		  />
</details>

<details>
  <summary>const используем, если не собираемся переопределять переменную/функцию. Функции обычно лучше создавать через const</summary>
</details>

<details>
  <summary>let используем если будем переопределять значение переменной</summary>
</details>

<details>
  <summary>Если название переменной начинается с нижнего подчеркивания - ее не надо менять или читать снаружи объекта напрямую.</summary> 
		Чтоб делать это - используй специальные методы: 
			сеттеры (set... - присвоить) 
			геттеры (get... - получить)
</details>

<details>
  <summary>Инкапсуляция = сокрытие лишних деталей</summary>
</details>

<details>
  <summary>Интерфейс - то как мы взаимодействуем с чем-то</summary>
	    - интерфейс объекта - какие свойства и методы у него есть
	    - интерфейс функции - её имя, какие параметры мы в неё передаём, какой ответ получаем...
</details>

<details>
  <summary>Идемпотентность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.</summary>
</details>

<details>
  <summary>Детерминированность - для одних и тех же исходных алгоритм выдаёт тот же результат.</summary>
		Результат однозначно определяется исходными данными.
</details>

<details>
  <summary>Иммутабельность - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.</summary>
</details>

<details>
  <summary>true && expression всегда вычисляется как expression, а выражение false && expression — как false.</summary>
</details>

<details>
  <summary>Math.ceil(x) - округляет x в большую сторону</summary>
</details>

<details>
  <summary>Promises - способ организации асинхронного кода. Объект, который содержит своё состояние. </summary>
		https://learn.javascript.ru/promise
		- Состояния promises:
				- вначале pending («ожидание»), 
				- затем либо fulfilled («выполнено успешно») 
				- либо rejected («выполнено с ошибкой»).
		- На promise можно навешивать коллбэки двух типов:
				- onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
				- onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
		- Способ использования, в общих чертах, такой:
				- Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
	    		- Внешний код, получив promise, навешивает на него обработчики.
	    		- По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
		- Обработчики назначаются вызовом .then/catch
			- .then = универсальный метод для навешивания обработчиков:
					- promise.then(onFulfilled, onRejected) //(удачно, неудачно)
			- .catch = чтобы поставить обработчик только на ошибку
					- вместо .then(null, onRejected) 
					- можно  .catch(onRejected) – это то же самое.
		- Синхронный throw – то же самое, что reject
			- Если в функции промиса происходит синхронный throw (или иная ошибка), то вызывается reject:
				let prom = new Promise((resolve, reject) => {
				  throw new Error("o_O");  // то же что reject(new Error("o_O"))
				})
				pprom.catch(alert); // Error: o_O
		- chaining (чейнинг)- возможность строить асинхронные цепочки из промисов
				- Пожалуй, основная причина, из-за которой существуют и активно используются промисы.
				- Например, мы хотим по очереди:
				    Загрузить данные посетителя с сервера (асинхронно).
				    Затем отправить запрос о нём на github (асинхронно).
				    Когда это будет готово, вывести его github-аватар на экран (асинхронно).
				    …И сделать код расширяемым, чтобы цепочку можно было легко продолжить.
				    	httpGet('/article/promise/user.json') //делаем запрос
						  .then(...)
						  .then(...)
						  .then(...)
				  	При чейнинге .then…then…then, в каждый следующий then переходит результат от предыдущего. 
				  	Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
</details>

<details>
  <summary>Прокси-объекты - особые объекты, которые позволяют перехватывать и изменять действия, выполняемые над другими объектами.</summary>
		В частности, речь идёт о вызове функций, об операциях присваивания, о работе со свойствами, о создании новых объектов, и так далее. 
		Эту технологию используют для блокирования прямого доступа к целевому объекту или целевой функции и организации взаимодействия с объектом или функцией через прокси-объект.

		Вот как выглядит объявление простого прокси-объекта, которому передаётся целевой объект и обработчик.
		let proxy = new Proxy(target, handler);

		Стандартное поведение объектов
		Объявим объект, а затем попробуем обратиться к несуществующему свойству этого объекта.
			let obj = {
			  c: "car",
			  b: "bike"
			};

			document.write(obj.b, ""); //Результат -> "bike"
			document.write(obj.c, ""); //Результат -> "car"
			document.write(obj.l); 	   //Результат -> "undefined"

		Использование прокси для объекта
		Используем обработчик с перехватчиком get. Обработчик передаст целевой объект и запрошенный ключ перехватчику.
			let handler = {
			    get: function(target, name) {
			    return name in target ? target[name] : "Key does not exist";
			  }
			}

			let obj = {
			  c: "car",
			  b: "bike"
			};

			let proxyObj = new Proxy(obj, handler);

			document.write(proxyObj.b, ""); //Результат -> "bike"
			document.write(proxyObj.c, ""); //Результат -> "car"
			document.write(proxyObj.l);     //Результат -> "Key does not exist"

  		https://habr.com/ru/company/ruvds/blog/359060/
</details>

<details>
  <summary>Функции-генераторы - function*</summary>
		https://learn.javascript.ru/generator
		Могут приостанавливать своё выполнение, возвращать промежуточный результат и возобновляться позже.
		Код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют «генератором»
</details>

<details>
  <summary>Итераторы - тип объектов, содержимое которых можно перебрать в цикле. Например массив, функция-генератор, список DOM-узлов, строка...</summary>
		https://learn.javascript.ru/iterator
		По сути - объект, предназначенный для перебора другого объекта.
		- Для перебора таких объектов добавлен новый синтаксис цикла: for..of.
		- итераторы дают возможность сделать «перебираемыми» любые объекты.
</details>

<details>
  <summary>Замыкание - это функция, содержащая в себе ссылки на переменные из внешней области видимости. Т.е. она "замыкает" внешние переменные в себе.</summary>
		https://learn.javascript.ru/closures
		это функция вместе со всеми внешними переменными, которые ей доступны.
	 	функции, получающие переменные из родительских областей видимости.
		+
		Вот ты вызвал функцию, в ней создаются переменные локальной области видимости, т.е. доступные только самой функции. Под эти переменные движок JavaScript выделяет память.
		Когда обычная функция завершает свое выполнение, освобождает память, которую выделял раньше, если на переменные не осталось ссылок.
		В случае с замыканием, ты возвращаешь функцию обратно, т.е. ссылки остаются, поэтому движок не может освободить память, и переменные остаются доступными функции, и более никому. Поэтому эта штука и называется замыкание, т.к. переменные замкнуты на саму функцию.
		Другими словами, чтобы создать замыкание, ты должен вложить функцию в функцию, обратиться из вложенной функции к переменным оборачивающей, и вложенную функцию вернуть наружу. До тех пор, пока возвращенная функция остается в доступе, замыкание существует.
		Один из основных паттернов, для которых применяются замыкания - ограничение доступа к данным, их изоляция (ограничение их области видимости).
		В то же время замыкание выступает в роли автономного атомарного хранилища данных, и, по идее, должно обеспечивать доступ к этим данным, тем или иным способом.
		+
		«Понимать замыкания» в JavaScript означает понимать следующие вещи:
		    - Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
		    - При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
		    - При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».
	    +
		Если на пальцах но у каждой функции есть область видимости. С внутренней функции мы можем доставать переменные с внешней функции. И еще менять. Это называют "брать из замыкания".
		Вообще, на сколько я знаю, то в функциональном программировании такой подход не приветствуется.
		+
		замыкание - способность функции запоминать контекст(e.g. LexicalEnvironment), в которой она была создана.
		Например в примере функция запоминила "a" из области своего создания, а потом, будучи вызванной уже вне этой области вернула это значение. 
		+
		function sayHi(name) {
		  var phrase = "Привет, " + name;
		  alert( phrase );
		}

		sayHi('Вася');
</details>

<details>
  <summary>debounce - возвращает обертку, которая откладывает вызов исходной функции на определенное время.</summary>
	    Превращает несколько вызовов функции в течение определенного времени в один вызов. 
	    Причем задержка начинает заново отсчитываться с каждой новой попыткой вызова. 
	    Возможны два варианта:
	    	- Реальный вызов происходит только в случае, если с момента последней попытки прошло время, большее или равное задержке.
	    	- Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не пройдет время, большее или равное задержке, отсчитанной от времени последней попытки.

    	http://gdrw.ru/reviews/tech/debounce-function-in-javascript
    	https://learn.javascript.ru/task/debounce
    	https://habr.com/ru/post/60957/
</details>

<details>
  <summary>Зачем при вызове функции ставят две двойные скобки? function()()</summary>
		Пример:
			var a = 1;
			function getFunc() {
			  var a = 2;
			  var func = function() { alert(a); };
			  return func;
			}
			getFunc()(); // 2, из LexicalEnvironment функции getFunc
		Функция getFunc() возвращает другую функцию (та что в переменной func). 
		Вторые скобки нужны чтобы вызвать функцию, которую вернула getFunc().
		Если скобки опустить, то return внешней функции вернет Вам не результат а саму функцию. 
</details>

<details>
  <summary>Утечки памяти в JS</summary>
		https://habr.com/ru/post/309318/
		- Глобальные переменные - неявное объявление
			Пример:
				function foo(arg) {
				    bar = "скрытая глобальная переменная"; // это то же: window.bar = "явно объявленная глобальная переменная";
				}
			Решение: добавляйте 'use strict'; в начало JavaScript-файлов
		- Глобальные переменные - явно объявленные, не вычищенные (кэши и т.д.)
			это касается глобальных переменных, использующихся для временного хранения и обработки больших блоков данных. Если вам нужна глобальная переменная, чтобы записать в неё большое количество информации, убедитесь, что в конце работы с данными её значение будет установлено в null или переопределено. 
			Примером увеличенного расхода памяти, связанным с глобальными переменными, являются кэши — объекты, которые сохраняют повторно используемые данные. Для эффективной работы их следует ограничивать по размеру. Если кэш увеличивается без ограничений, он может привести к высокому расходу памяти, поскольку его содержимое не может быть очищено сборщиком мусора.
		- Забытые таймеры и коллбэки 
			Например: 
				var someResource = getData();
				setInterval(function() {
				    var node = document.getElementById('Node');
				    if(node) {
				        // Сделаем что-нибудь с node и someResource.
				        node.innerHTML = JSON.stringify(someResource));
				    }
				}, 1000);
		- Забытые обработчики событий 
			Обработчики следует удалять, когда они становятся не нужны, или ассоциированные с ними объекты становятся недоступны. 
			В прошлом это было критично, так как некоторые браузеры (Internet Explorer 6) не умели грамотно обрабатывать циклические ссылки. 
			Большинство современных браузеров удаляет обработчики событий, как только объекты становятся недостижимы. 
			Однако по-прежнему правилом хорошего тона остаётся явное удаление обработчиков событий перед удалением самого объекта.
			Рекомендуется явно удалять обработчики событий (removeEventListener) до удаления DOM-узлов или обнулять ссылки внутри обработчиков.
		- Ссылки на удалённые из DOM элементы
		- Замыкания - при опр. условиях
</details>

<details>
  <summary>Мемоизация - разновидность кэширования</summary>
		https://habr.com/ru/company/ruvds/blog/332384/
		- Запоминаем предыдущие результаты вызова функции, и если вызывается снова - используем их из кэша
		- Для того, чтобы функцию можно было подвергнуть мемоизации, она должна быть чистой, всегда возвращать одни и те же значения в ответ на одни и те же аргументы.
		- Мемоизация — это компромисс между производительностью и потреблением памяти. Мемоизация хороша для функций, имеющих сравнительно небольшой диапазон входных значений, что позволяет достаточно часто, при повторных вызовах функций, задействовать значения, найденные ранее, не тратя на хранение данных слишком много памяти.
		- Может показаться, что собственные реализации мемоизации стоит применять, например, при обращениях к неким API из браузерного кода. Однако, делать этого не нужно, так как браузер автоматически кэширует их, используя, в частности, HTTP-кэш.
		- Если вы работаете с React/Redux, можете взглянуть на reselect. Тут используется селектор с мемоизацией. Это позволяет выполнять вычисления только в том случае, если в соответствующей части дерева состояний произошли изменения.
		- Пожалуй, лучше всего функции с мемоизацией показывают себя там, где выполняются сложные, ресурсоёмкие вычисления. Здесь данная техника может значительно повысить производительность решения. Надо отметить, что нечто вроде вычисления факториала или чисел Фибоначчи — это хорошие учебные примеры, но в реальном мире всё гораздо интереснее и сложнее.


ПОНЯТИЯ REACT

	- React — это библиотека для создания пользовательских интерфейсов. Facebook
		Библиотека, которая умеет эффективно отрисовывать HTML - реагировать на кнопки и т.д. Эффективно рисует UI

	- Элементы - то, из чего «сделаны» компоненты.
	    Если просто: элемент – это то, что вы хотите видеть на экране.
	    Если не так просто: элемент – объектное представление некоторого пользовательского интерфейса.
	    С компонентом все иначе. Это класс или функция, что может принимать данные и возвращать элементы (обычно с использованием техники создания элементов React JSX).

	- Компоненты — это объекты JavaScript, которые представляют HTML-элементы. 
		Компонент = JavaScript-функция, которая возвращает кусок кода, представляющего фрагмент страницы. 
		Описывают DOM-элементы (h1, div, section...) Обычно это части пользовательского интерфейса, которые содержат свою структуру и функциональность. 
		Например, такие как NavBar, LikeButton, или ImageUploader. 
		Благодаря синтаксису JSX совмещает и разметку, и логику
		Концептуально, компоненты подобны JavaScript-функциям. Они принимают произвольные данные (называемые props) и возвращают React-элементы, описывающие что должно появиться на экране. 

	- Контейнерная компонента - берёт на себя общение со Store (ООП-объект, хранящий state). И позволяет поддерживать внутреннюю компоненту чистой
		    Презентационные компоненты - отвечают лишь за внешний вид приложения и не осведомлены о состоянии Redux. 
		    	Они получают данные через свойства и могут вызывать коллбэки, которые также передаются им через свойства.
		    Компоненты-контейнеры - ответственны за работу внутренних механизмов приложения и взаимодействуют с состоянием Redux. 
		    	Их часто создают с использованием react-redux, они могут осуществлять диспетчеризацию действий Redux. 
		    	Кроме того, они подписываются на изменения состояния.

	- Virtual DOM — это дерево React элементов на JavaScript. 
		React отрисовывает Virtual DOM в браузере, чтоб сделать интерфейс видимым. 
		React следит за изменениями в Virtual DOM и автоматически изменяет DOM в браузере так, чтоб он соответствовал виртуальному.

	- Свойства (props) - произвольные данные, которые принимают компоненты. Это могут быть и функции		
		Это информация, коллективно используемая родительским компонентом и компонентами-потомками. 
		Они предоставляются в качестве аргументов компонента и выглядят так же, как атрибуты HTML. 
		Свойства необязательно должны представлять собой какие-то данные. Они могут быть и функциями.
	    
	    <Photo imageURL='http:tinyurl.comlkevsb9' caption='New York!' /> (см. imageURL & caption).
	    <PlayButton isMusicPlaying={this.state.isMusicPlaying} />

	- Композиция - комбинирование меньших компонентов при формировании большего. 

	- State (анг: состояние) — специальный js-объект <внутри компонента>. Хранит данные, которые могут изменятся с течением времени. 
		см ниже (Redux)

	- Reverse Data Flow - обратный поток данных.. Из дочернего элемента влиять на состояние родительского

	- State lifting - подъём состояния. Перенос данных / функций из дочернего элемента в родителя, чтоб они были доступны нескольким потомкам.
		 А из потомка вызываю эти обработчики как коллбэки или получаю эти данные в виде пропс.

	- key - уникальное свойство (prop), связывает данные и элементы React. 
		Например, если надо удалить одну статью из 10 - он удалит только статью с нужным key, а остальные перестраивать не будет. 
		См https://www.youtube.com/watch?v=tn9HyYRVZ9A (7. Отображение массивов, смысл аттрибута key). 
		Поэтому идеальные ключи должны браться из самих данных - id, уникальный title или ещё что-то в этом роде

	- refs - «достучаться» к конкретному элементу и вызвать метод. Надо добавить атрибут ref в компонент для обратного вызова. 
		Предположим, нам понадобилось «достучаться» к конкретному элементу и вызвать метод. 
		React.JS refs нужен как раз для этого. Добавить атрибут ref в компонент для обратного вызова. 
		Например:
			class UnControlledForm extends Component {
			  handleSubmit = () => {
			    console.log("Input Value: ", this.input.value)
			  }
			  render () {
			    return (
			      <form onSubmit={this.handleSubmit}>
			        <input
			          type='text'
			          ref={(input) => this.input = input} />
			        <button type='submit'>Submit</button>
			      </form>
			    )
			  }
		    }

    - PureComponent изменяет lifecycle-метод shouldComponentUpdate, автоматически проверяя, нужно ли заново отрисовывать компонент.
    	https://habr.com/ru/company/redmadrobot/blog/318222/
    	https://medium.com/frontend-notes/purecomponent-%D0%B8-components-5c15cf206ba7


REDUX
	- Redux = библиотека для управления state, которая реализует Flux-архитектуру
		Её надо инсталлировать отдельно
		Позволяет создавать свой store командой, а не вручную
		В частности, уменьшает связность - позволяет передавать данные не по цепочке props,  а сразу в нужную компоненту

	- React-redux = отдельная библиотека, выступает как прослойка между React и Redux. 
		Позволяет работать с Redux не заморачиваясь кучей сложностей. 
		Инкапсулирует часть вещей, прячет от нас всякие детали связанные с контекстом, store, dispatch, subscribe...

	- State (анг. состояние) — специальный js-объект <внутри компонента>. Хранит данные, которые могут изменятся с течением времени. 
		https://ru.reactjs.org/docs/state-and-lifecycle.html
		Это инструмент, позволяющий обновлять пользовательский интерфейс, основываясь на событиях. 
		Задачи компоненты - отрисовывать какие-то данные. Эти данные всегда называются state (состояние приложения). 
		Узнать состояние компонента можно с помощью конструкции this.state. 
		Изменить состояние можно с помощью this.setState(), если передадим этой функции объект, представляющий новое состояние. 

		- state-managment - управление данными
			Задумывая архитектуру нового приложения, первым делом всегда думать - как я собираюсь организовать state-managment (управление данными)? 
			Чаще всего выбор зависит от того, в чём больше опыта. 
			State (Business Logic Layer) важнее чем UI.
			Какие есть подходы к state-managment?
			    - local state of class component - локальный state классовых компонент. Используется не всегда. Для простых, небольших задач, маленьких проектов.
			    - Redux (одна из реализаций FLUX) - функциональное програмирование
			    - MobX - ООП
			    - и ещё много других

		- Не изменяйте state напрямую
			// Неправильно
			this.state.comment = 'Привет';

			Вместо этого используйте setState():
			// Правильно
			this.setState({comment: 'Привет'});

			Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.

		- Обновления state могут быть асинхронными
			React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.

			Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.

			Например, следующий код может не обновить счётчик:

			// Неправильно
			this.setState({
			  counter: this.state.counter + this.props.increment,
			});

			Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:

			// Правильно
			this.setState((state, props) => ({
			  counter: state.counter + props.increment
			}));

		- Однонаправленный поток данных
			В иерархии компонентов, ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. 
			Также не важно, как был создан определённый компонент — с помощью функции или класса.
			Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.
			Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов:

				<h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>

			Своё состояние можно передать и другому пользовательскому компоненту:

				<FormattedDate date={this.state.date} />

			Компонент FormattedDate получает date через пропсы, но он не знает, откуда они взялись изначально — из состояния Clock, пропсов Clock или просто JavaScript-выражения:

				function FormattedDate(props) {
				  return <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>;
				}

			Этот процесс называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.

			Если представить иерархию компонентов как водопад пропсов, то состояние каждого компонента похоже на дополнительный источник, который сливается с водопадом в произвольной точке, но также течёт вниз.

	- Store (анг. хранилище) - ООП-объект, который управляет state (объект хранящий состояние приложения). 
		Там лежит: 
			- сам state
			- методы для работы с ним
		Создаётся при помощи метода(?) createStore(reducers)
	  
	- Dispath (анг. отправка) - метод объекта store, через который вызываем все другие методы объекта Store (что изменить state, т.е. состояние приложения). 
		Мы вводим в наш объект store один единственный метод, через который будем вызывать все другие методы объекта.
		Он принимает некий объект action. Выглядит так: dispath(action). 
		У action обязательно должно быть текстовое свойство type='' - в нём передаётся название требуемого действия (т.е. метода). 
		Эти текстовые названия всегда пишутся заглавными.
		State всегда меняется через dispath(action)

	- Action - объект, который через метод dispath передаётся в наш объект store, и там производит некие действия с данными (state). 
		У action есть как минимум одно свойство, type. 
		По type dispath определяет, какие именно действия надо произвести со state (какую ветку действий выбрать)

	- Action Creator - функции, которые возвращают объект action. То, что передаётся в mapDispatchToProps
		Содержит action - type и список данных, которые может получать. 
		Пример:
			export const updateTaskStatus = (status, id) => ({
			  type: UPDATE_TASK_STATUS,
			  newStatus: status,
			  taskId: id,
			});

	- Reducer (анг. уменьшатель) - чистая функция, принимает state и action. Та самая простынь, где много switch
		Применяет action к этому state (если нужно) и возвращает новый state (если не изменился - тот же). 
		Позволяет разделить метод dispath на отдельные куски, чтоб с ним было удобнее работать. 
		Обычно каждый reducer отвечает за какую-то ветку state - например этот работает с одной страницей, а тот с другой; или один работает с цитатами, а другой с пользователями. 
		Reducers - это отдельные функции, а не методы объекта store. Они лежат отдельно от store. Поэтому store (и его метод dispatch) не в курсе, какой action какому reducer нужен - мы отправляем любой входящий action всем имеющимся reducers. Для работы reducer ему кроме action нужен ещё и state. Но, мы не отправляем весь state целиком каждому reducer - нет, каждому мы отправляем только ту ветку, с которой он работает.
		Reducer - только преобразователь. Он не вызывает subscriber и другие callbacks.
		Если тип action неизвестен - выдаём изначальный state

		const task_tables_reducer = (state = initialState, action) => {
		  switch(action.type) {
		    case IS_PAGINATION: {
		      return {...state};
		    }
		    default:
		      return state;
		  }
		}

	- connect(mapStateToProps, mapDispatchToProps) - API-функция предоставляемая пакетом react-redux. 
		Позволяет создавать контейнерные компоненты
		Пробрасывает в презентационную компоненту данные из store, в виде props. Благодаря mapStateToProps
		Подписывает презентационную компоненту на все изменения state, которые мы объявили в mapStateToProps
		Позволяет контейнерной компоненте изменять store, благодаря mapDispatchToProps
		Connect автоматически делает подключенные компоненты «чистыми», то есть они будут повторно рендериться только при изменении их props — тоесть, когда изменяется их срез состояния Redux. Это предотвращает ненужный ре-рендер и ускоряет работу приложения.

	- mapDispatchToProps - объект, содержащий набор actionCreators. 
		Используется в connect
		Позволяет контейнерной компоненте диспатчить изменения в store

	- Provider - компонента, оборачивается вокруг корневой компоненты (<App>). Позволяет передавать store всем потомкам - теперь у connect() есть доступ к store.
		- пакет react-redux предоставляет разработчику компонент <Provider>, который можно использоваться для оборачивания корневого компонента приложения. Он принимает свойство store. Предполагается, что оно представляет собой ссылку на хранилище Redux, которое планируется использовать в приложении. Свойство store передаётся, в соответствии с иерархией приложения, компонентам-контейнерам, с использованием механизма контекста React:


REDUX & AJAX

	- самый простой вариант - делаем запрос внутри actionCreator. 
		Например, при помощи fetch:
			const fetchDog = (dispatch) => {
			  dispatch(requestDog());
			  return fetch('https://dog.ceo/api/breeds/image/random')
			    .then(res => res.json())
			    .then(
			      data => dispatch(requestDogSuccess(data)),
			      err => dispatch(requestDogError())
			    );
			};
		Это простой, но очень негибкий подход. 
		Ядро Redux это контейнер состояния (state container), который поддерживает только синхронные потоки данных.
		В случае асинхронного вызова, надо сначала дождаться ответа и затем (если не было ошибок) обновить состояние. А  если у приложения сложная логика?
		Для этого Redux использует промежуточные слои (middlewares) - код, который выполняется после отправки действия, но перед вызовом редюсера.
		Промежуточные слои могут соединяться в цепочку вызовов для различной обработки действия (action), но на выходе обязательно должен быть простой объект (действие)

	- middlewares - промежуточные слои Redux. Используются для реализации асинхронности в Redux	
		- функция, которая запускается каждый раз при отправке action’а
		- Ядро Redux это контейнер состояния (state container), который поддерживает только синхронные потоки данных. 
		На каждое действие, в хранилище (store) посылается объект, описывающий что произошло, затем вызывается редюсер (reducer) и состояние (state) сразу обновляется.
		- Промежуточный слой это кусок кода, который выполняется после отправки действия, но перед вызовом редюсера.
		- Промежуточные слои могут соединяться в цепочку вызовов для различной обработки действия (action), но на выходе обязательно должен быть простой объект (действие)
		- Для асинхронных операций, Redux предлагает использовать redux-thunk промежуточный слой.

		Написание собственной middleware не так сложно, как может показаться, и позволяет использовать некоторые мощные средства.
		Например…
		    Хотите посылать API-запрос каждый раз, когда имя action’a начинается с FETCH_? Вы можете сделать это с помощью middleware.
		    Хотите централизованное место для логирования событий в вашем аналитическом ПО? Middleware — хорошее место для этого.
		    Хотите предотвратить запуск action’a в определенный момент времени? Вы можете сделать это с помощью middleware, невидимого для остальной части вашего приложения.
		    Хотите перехватить action, имеющий токен JWT, и автоматически сохранить его в localStorage? Да, middleware.


	- redux-thunk - библиотека, один из вариантов реализации middleware (промежуточный слой) для React-Redux
		https://habr.com/ru/post/351168/
		https://monsterlessons.com/project/lessons/reduxjs-asinhronnye-eksheny-s-pomoshyu-redux-thunk
		https://tuhub.ru/posts/redux-i-thunk-vmeste-react-rukovodstvo-dlya-chajnikov

		- thunk = преобразователь (англ)
		- стандартный путь выполнения асинхронных операций в Redux.
		- вводит понятие функции-преобразователя, которая вызывается внутри dispatch и уже по завершении своей работы возвращает нормлаьный dispatch (вызовет необходимый метод для изменения store)
		- вызываем dispatch, как обычно. Но передаем в него не обьект, а функцию-1, которая возвращает функцию-2. 
			В возвращаемой функции-2 есть аргумент dispatch. 
			Теперь мы можем в этой функции-1 делать любые асинхронные операции и вызывать dispatch тогда, когда нам нужно.
		- Преимуществом использования redux-thunk является то, что компонент не знает, что выполняется асинхронное действие.
			Т.к. промежуточный слой автоматически передает функцию dispatch в функцию, которую возвращает генератор действий, то снаружи, для компонента, нет никакой разницы в вызове синхронных и асинхронных действий (и компонентам больше не нужно об этом беспокоиться)

		- thunk = функция, которая выполняет асинхронную операцию и на выходе диспатчит какие-то action в reducers. 
			Саму функцию thunk тоже можно задиспатчить 
			По сути, thunk = название функции, в которой происходит какая-то логика.
			Эта функция производит какие-то асинхронные действия и при этом умеет вызывать различные dispatch по результатам этих асинхронных действий. 
			Чтобы она могла вызывать метод dispatch, он должен прийти в неё - т.е. dispatch надо передать в параметрах этой функции при её вызове
			Функцию thunk запускает Redux. Мы её диспатчим, а Redux store её запустит и закинет в неё свой метод dispatch.

			А откуда функция thunk получит данные, которые должна обработать? Например, текст сообщения, которое она должна послать AJAX'ом на сервер? Передать эти данные как параметр функции мы не можем, т.к. вызывать её будет store. 
			Эти данные она возьмёт из замыкания. 
			Чтоб возникло замыкание, функцию thunk надо вернуть из некоей родительской функции (тогда thunk получит доступ к данным родительской функции).
			Используем родительскую функцию ThunkCreator: 
				- В ThunkCreator передаём данные (для передачи AJAX'ом на сервер, например), 
				- ThunkCreator вернёт нам thunk (уже с замыканием в котором есть нужные данные).
				- полученную функцию thunk мы диспатчим в Redux store 
				- Redux при вызове thunk передаст в неё метод dispatch (чтоб thunk могла по результатам своей работы что-то задиспатчить в store)
			Т.е. по факту, мы: 
				- диспатчим вызов ThunkCreator, в который передаём данные
				- ThunkCreator вызовет thunk (данные уже в нём благодаря замыканию), 
				- thunk выполнит AJAX-логику 
				- и по результатам вызовет какие-то dispatch, которые уйдут в reducers.

			Один момент: store не умеет принимать функции (он ждёт объект со свойством type, чтоб раскидать по reducers). 
			То есть, store не может принять thunk :(
			Поэтому, приходится использовать middleware (промежуточный слой) - он вклинивается между приёмником dispatch в store и моментом передачи диспатчей по reducers. 
			Мы должны при создании store немного его перенастроить, чтоб добавить middleware в цепочку. 
			Получается такая логика:
				- если на вход поступил обычный dispatch - он проходит middleware насквозь и уходит в reducers. 
				- но, если на входе пришла функция (thunk) - она обрабатывается middleware, и её результаты снова отправляются на вход Store.
				- если эти результаты = ещё один thunk, то процесс повторяется (да, thunk могут быть вложенными)
				- если эти результаты = dispatch, то он проходит middleware насквозь и уходит в reducers. 
			

			https://www.youtube.com/watch?v=eWdnjfRu9Io

	- redux saga - другая библиотека, для реализации middleware (промежуточный слой) React-Redux
		- Для упрощения и улучшения сайд-эффектов в приложениях React-Redux. Прежде всего - асинхронные запросы (извлечение данных и т.д.) и нечистые вещи (доступ к кешу браузера и т.д.)
		- Их легче тестировать, на них легче реализовать сложную логику (задержки, параллельные задачи, отмена задач,)
		- Саги это дизайн паттерн, который пришел из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.
		- Работают на основе функций-генераторов
		- Если говорить в общем, мы имеем сагу чья работа это следить за отправленными действиями (dispatched actions). И ещё одна сага-рабочий
		- Сага-наблюдатель (watcher saga) является ещё одним неявным слоем. Дает больше гибкости для реализации сложной логики, но иногда лишняя для простых приложений.
		- Effects. Методы внутри саг(?) возвращают не dispatch action, а объекты с инструкциями для промежуточного слоя (middleware) —  отправить действие. Эти возвращаемые объекты называются Эффекты (Effects)
		
		- Есть альтернативы redux-saga, которые стоит попробовать. Две самых популярных это:
			- redux-observable (который базируется на RxJS) 
			- redux-logic (также базирующийся на RxJS наблюдателях, но дающий свободу писать вашу логику в других стилях).

	- axios - инструмент для отправки ajax-запросов, основанный на промисах, очень похожий на jQuery.
		- Альтернативы: got, fetch, SuperAgent, jQuery

	- Вариант организации AJAX (IT-Kamasutra)
		https://www.youtube.com/watch?v=c34P8-9YVMQ&list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8&index=51

		для работы с серверным API & AJAX - используем axios  
		Изначально у нас в стэйте нет данных (например, списка задач) - мы должны получить их с сервера
		Берём reducer, в котором эти данные выводятся и соответствующий action
		Создаём новый action = setTasks //получить-установить задачу
		В reducer пишем реакцию на этот action - добавить в state данные из объекта, который приходит с этим action
		В контейнерной компоненте, в функции mapStateToProps добавляем в state компоненты задачи из общего state 
		В контейнерной компоненте, в функции mapDispatchToProps создаём callback для вызова этого action. При вызове этого action - он добавит задачи в state 
		Сам факт захода пользователя на страницу со списком задач = действие (т.е. диспатч), которое вызывает этот action. 


CONTEXT API
	https://habr.com/ru/post/419449/

	- 3 составляющих Context API:
		- Функция React.createContext, которая создает context
	    - Provider (возвращается createContext) - устанавливает «электрическую шину» для прямой передачи данных, проходящую через дерево компонентов
    	- Consumer (возвращается createContext) - впитывается в «электрическую шину» для извлечения данных

	- Provider очень похож на Provider в React-Redux. Он принимает значение, которое может быть всем, чем хотите (это может быть даже store Redux… но это было бы глупо). Скорее всего, это объект, содержащий ваши данные и любые actions, которые вы хотите выполнить с данными.
	- Consumer работает немного похоже как функция connect в React-Redux, подключаясь к данным, и сделав их доступными для компонента, который их использует.

	- Контекст - объект, который создаётся у родителя и доступен всем детям. 
	  	Может содержать некоторые очень глобальные данные - активный язык приложения (ru/en), активную тему оформления (ночь/день), store... 
	  	Т.е. что-то, что редко меняется 
	  	Что попало туда пихать не надо, только очень глобальные вещи. 
	  	Контекст нужен чтобы не пробрасывать некоторые данные по длинной цепочке только для того, чтоб они пришли в компоненту нижнего уровня - эти данные помещаются в контекст а компонента нижнего уровня берёт их сразу оттуда, не из props.
	
	- Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.


CSS

	- Если нужно добавить свой CSS - создаю для этого компонента отдельную папку (название = названию компонента), в ней файл компонента (index.js) и style.css

	- CSS лучше писать по BEM-методологии - http://ru.bem.info/methodology

	- Использовать css modules. 

	- Ещё крутая штука - Styled Components. Читать


JSX

	- JSX - специальный синтаксис, синтаксический сахар для JS. 
	 	https://learn.javascript.ru/screencast/react#03-jsx
		При помощи Babel он компилируется в обычный JS. В JSX пишется и html-содержимое компонентов.
	 	Расширение .jsx использоватьтолько для компонент. Не использовать для редьюсеров и т.д.т

		- JSX - синтаксическое расширение JavaScript. 
			JSX производит React-элементы. 
			Можно работать с React на обычном JS, без JSX. 
			Babel компилирует JSX в вызовы React.createElement().

	- Почему JSX?
		React учитывает тот факт, что логика отрисовки связана с другой логикой пользовательского интерфейса: как обрабатываются события, как изменяется состояние со временем и как данные подготавливаются для отображения.
		Вместо того, чтобы искусственно отделять технологии, помещая разметку и логику в отдельные файлы, React разделяет задачи , используя слабо связанные единицы, называемыми «компонентами», которые содержат и разметку, и логику. 

	- В JSX нельзя вывести два html-элемента рядом, вот так:
		function Test() {
			return (
				<h1>Title</h1>
				<p>Text</p>
				<div></div>
			)
		}

		Надо так:
			function Test() {
				return (
					<div>
						<h1>Title</h1>
						<p>Text</p>
					</div>
				)
			}

		Или так:
			function Test() {
				return [
					<h1 key = 'a'>Title</h1>,
					<p  key = 'b'>Text</p>
				]
			}


		- чтоб создать в JSX пустую корневую компоненту можно сделать так:
			return <>
				<ComponentOne />
				<ComponentTwo />
			</>

    	Иначе - только через массив с уникальными ключами

	- В JSX обязательно надо закрывать открытый тэг. Но, можно использовать такой синтаксис <Article /> 

	- В JSX есть соглашение - все кастомные (т.е. мной созданные) компоненты называются с большой буквы (Aricle, MyComponent...). 
		Т.к. компонент = класс. 
		И при выводе их внутри других компонентов - тоже (<Aricle />, <MyComponent />, ...)

	- В JXS, если надо написать кусок на обычном JS, я помещаю его в фигурные скобки. 
		Например, создаю и вывожу переменную
			function Test() {
				const text = <p>Text</p>
				return (
					<div>
						<h1>Title</h1>
						{text}
					</div>
				)
			}

		Лучше не злоупотреблять выводом внутри JSX фигруных скобок с JS - тяжело разбираться. 
		Если нужны большие объёмы - выноси в переменные (см выше)

	- В JXS аттрибуты html пишут так:
			function Test() {
				return (
					<div className="test" style={{color: 'red'}}>
						<h1>Title</h1>
					</div>
				)
			}

	- JSX предотвращает атаки, основанные на инъекции кода. 
		https://ru.reactjs.org/docs/introducing-jsx.html
		Данные, введённые пользователем, можно безопасно использовать в JSX. 
		По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. 
		Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
		Всё преобразуется в строчки, перед тем как быть отрендеренным. 
		Это помогает предотвращать атаки межсайтовым скриптингом (XSS).

    - Все атрибуты элементов React именуются с помощью camelCase. 
		CSS-class записываем как className
		tabindex = tabIndex

	- Внутри JSX разметки можно использовать только готовые выражения. 
		Нельзя, например, использовать конструкцию if/else (точно?)
		но можно заменить ее тернарным оператором.


КОМПОНЕНТЫ

	- Компонент = функция. Возвращает какую-то JSX разметку. 
		Когда компонент создан, автоматически появляется тэг <Имя_Компонента /> - при его помощи мы выводим этот JSX в нужном месте.
		Эта функция является активным компонентом React потому что она принимает на вход объект argument c данными и выдает элемент React. 
		Можно назвать такие компоненты «функциональными», поскольку буквально они являются функциями JavaScript. 

	- На каждый компонент заводить отдельный файл. 

	- Компоненты обычно располагаются в src/components. 

	- Название файла обычно = названию компонента, также с большой буквы. 
		Например:
		src/components/Article.js

		- Названия компонентов начинаются с заглавной буквы. Это важно, так как в работе будут сочетаться HTML-элементы и элементы Реакта. Названия со строчных букв зарезервированы для HTML. Если вы попробуете назвать элемент просто button, при рендере фреймворк проигнорирует его и отрисует обычную HTML-кнопку.

	- Каждый раз добавляя новую функциональность - думать чтоб вынести её в отдельный компонент

	- Всегда прописывайте названия компонентов с заглавной буквы (см выше)

	- Чистые функции

		- Все компоненты React должны действовать как чистые функции, сохраняя свои свойства. 
			Чистые функции не пытаются ничего изменить и всегда отдают тот же результат (при условии, что на вход подаются одни и те же данные).

		- Никогда не менять по ссылке внешние (глобальные) переменные, массивы и т.д. 
			Не сортировать и вообще не трогать. Особенно то, что приходит в props. 
			Если надо изменить - создавай в компоненте отдельную переменную, записывай в неё, и её меняй. 
			Подробнее: https://www.youtube.com/watch?v=NhT5nMvve4Q (11. Отладка React-приложений)

		- т.к. у нас функциональное программирование, надо придерживаться принципа "чистоты функций"
			Функция не должна работать ни с какими глобальными объектами или генерировать данные. Всё с чем она работает - только с тем, что приходит в неё через props (т.е. через параметры функции). 
			И возвращаемая разметка должна зависеть только от входящих значений props - если 100 раз вызвать функцию с одними и теми же значениями props, мы 100 раз получим один и тот же результат

		- Чистая функция:
			- идемпотента 	    - при повторении операции даст тот же эффект
			- детерминирована   - для одних и тех же данных всегда выдаёт тот же результат
			- иммутабельна      - неизменяемость. Функция не меняет входящие данные. Делает копию, и работает уже с ней.
			- без сайд-эффектов - побочных эффектов 
				Например: какой-то внешний объект изменился, и при тех же входящих данных мы получили новый результат

		- Пропсы можно только читать!
			Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
			Возьмём для примера функцию sum:
				function sum(a, b) {
				  return a + b;
				}
			Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.

			А вот пример нечистой функции — она записывает данные в свои же аргументы:
			function withdraw(account, amount) {
				  account.total -= amount;
				}
			React достаточно гибкий, но есть одно правило, которое нельзя нарушать: React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.

	- Props. Все данные в компонент приходят в первом аргументе. Обычно он называется props (сокращение от properties).
		Любой компонент может принимать параметры, которые потом использует внутри себя. Например, текст, который надо вывести внутри JSX-разметки, генерируемой компонентом. Главный такой параметр называется props (это просто название параметра, оно принято в React). Т.е. React, вызывая компонент, всегда передаёт в этот параметр props некий объект. Находясь внутри компонента я могу получать данные, которые пришли внутри этого props.

		Чтоб при вызове компонента передать что-то в его props - достаточно прописать некий атрибут, например name='Dima' превратится в props.name
		
			const User = (props) => {
				return (
					<p> {props.name} </p>
					<p> {props.age} </p>
				)
			}

			<User name='Dima' age='30' />

		- props = объект, который позволяет передать в компонент какие-то данные. Или предать callback - функцию, которая компонента потом сможет запустить. Т.е. сама функцию создана в одном файле, но если передать её через props - вызывается из другого файла

		- правильный подход - прокидывать в компоненты как можно меньше лишней информации props. Чтоб компоненты оставались "чистыми", "презентационными". Чтоб, в идеале, компонента ничего не знала про store - чтоб мы никак не были завязаны на store, тогда в будущем можно использовать эти компоненты с другими реализацями state-managmant (MobX, ...)

		- Первый аргумент функции, создающей компонент. В него приходят все данные, с которыми мы работаем в компоненте.

		- Каждый элемент имеет список свойств (атрибутов), как и в HTML. В Реакте это называется props.

		- Пропсы можно только читать!
			Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.
			Возьмём для примера функцию sum:
				function sum(a, b) {
				  return a + b;
				}
			Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо возвращают один и тот же результат для одинаковых аргументов.

			А вот пример нечистой функции — она записывает данные в свои же аргументы:
			function withdraw(account, amount) {
				  account.total -= amount;
				}
			React достаточно гибкий, но есть одно правило, которое нельзя нарушать: React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.

	- Контейнерная компонента - обёртка вокруг презентационной компоненты, чтоб сохранить её чистой (не зависимой от props, store, state...)
		Тогда презентационную можно будет пере-использовать в других проектах и т.д.  
		Т.е. чтоб презентационная компонента не использовала actionCreator из dispatch и прочее. 
		Вместо этого мы всё получаем через props, а вместо dispatch используем callbacks. 

		С другой стороны, если бы контейнерной компоненты не было - нам нужно было бы каждый callback прокидывать из store через всё дерево в каждую презентационную компоненту. Это неудобно. 
		Поэтому мы до контейнерной компоненты прокидываем обычный dispatch + state, в ней вызываем отрисовку чистой презентационной компоненты, и передаём ей (через props) из этого dispatch колбэки и state.

		Контейнерная компонента общается со Store через context API (https://ru.reactjs.org/docs/context.html)

		- Контейнерная компонента - берёт на себя общение со Store (ООП-объект, хранящий state). 
				И позволяет поддерживать внутреннюю компоненту чистой
				Прокидывает в неё данные из Store (props, dispatch колбэки) 
		  		отрисовывает презентационную компоненту

		- Если кратко, компоненты-контейнеры отвечают за данные и операции с ними. Их состояние передается в виде свойств в компоненты-представления и отображается.

	    - Организация контейнерных компонент и AJAX 
			- снаружи - контейнерная, которая через connect работает со Store
			- в ней (в том же файле) - классовая, которая делает AJAX-запросы и прочие сайд-эффекты
			- классовая вызывает отрисовку функциональной (которая лежит в отдельном файле). Та получает только props и отдаёт JSX
	
	- Презентационная компонента - чистая компонента, получает props, отдаёт JSX.
		Всё получает через props (из контейнерной компоненты), а вместо dispatch используем callbacks. 

	- Есть два типа компонентов - функциональные и классовые
		- функциональные - states - очень простые (тупые), без состояний (presentational, stateless, dumb). Это функция, которая принимает props и возвращает JSX
		- классовые - с использованием классов ES6 - с состояниями. Можно использовать методы жизненного цикла. Необходимы, если компонент имеет состояние или значимые методы.
	  React-разработчики стараются минимизировать использование классовых компонент. Если можно решить вопрос функциональной компонентой - так и делай
	  
	  - smart-компоненты - манипулируют данными
	  - dumb-компоненты - что-то отрисовывают



		- Два типа синтаксиса
		    - функциональные компоненты. 
		        Для очень простых компонентов, почти без логики (stateless компоненты):
		            import React, {Component} from 'react';
		            function Article(props) {}
		    - классовый компонент (классы компонентов). 
		        Позволяет использовать дополнительные возможности, такие как локальное состояние и методы жизненного цикла.
		        Наследуется от базового компонента Component
		        Должны содержать функцию render()
		        Компоненты, основанные на классах, могут хранить информацию о текущей ситуации. Эта информация называется состоянием (state), она хранится в JS-объекте.
		        
		        import React, {Component} from 'react';
		        class Article extends PureComponent {
		          render () {}
		        }
		        
		        метод render нужен обязательно, он отвечает за то, как будет выглядеть компонент.
		        props будет жить в this.props

	- Классовые компоненты
		- класс, который наследуется от метода React.Component, у которого есть как минимму метод render, и который возвращает JSX
		- Для чего нужны классы? Чтоб создавать однотипные объекты на базе этих классов и реализовать в них концепции ООП (инкапсуляция, полиморфизм, наследование)
			- Полиморфизм - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
			- Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
			- Инкапсуляция – сокрытие деталей. Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.
			- Абстрагирование – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.

	- Методы и обработчики классовых компонент писать так (кроме render): onClick = () => {}
		https://www.youtube.com/watch?v=vO63wxg4aKY
		Позволяет решить вопросы c контекстом вызова (bind и т.д.) - 
		Нен забыть, что все обработчики (практически все) объявляются внутри классовой компоненты, как её метод

	- setState - метод компонента. Обновляет его состояние, и вызывает перерисовку
		Вызов setState позволяет React перестроить ваше приложение и обновить DOM.
		Обычно когда необходимо обновить компонент вы просто вызываете setState с новым значением переданным в виде объекта в функцию setState: 
			this.setState({someField:someValue})

		- setState - использование стрелочной функции вместо объекта
			https://clck.ru/GDfFh
			раньше: setState(nextState)
			теперь: setState((s,p) => s) 

			позволяет использовать текущее состояние this.State, не опасаясь, что произойдёт что-то не то.  
			То есть: позволит получить вам достоверные значения для state и props компонента. 
			Иначе: так как this.props и this.state могут обновляться асинхронно, то не стоит полагаться на их значения для вычисления нового состояния. 
			Т.е. я хочу просто инвертировать свойство внутри state (например open/close), и делаю !this.state.isOpen. Но, к моменту выполнения кода этот параметр может уже измениться из другого места, и я получу неожиданный результат

		- Обновления state могут быть асинхронными
			React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.

			Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.

			Например, следующий код может не обновить счётчик:

			// Неправильно
			this.setState({
			  counter: this.state.counter + this.props.increment,
			});

			Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:

			// Правильно
			this.setState((state, props) => ({
			  counter: state.counter + props.increment
			}));

		- Set State перестраивает весь виртуальный DOM компонента, на котором он вызван. 
			И всех его вложенных компонентов! А потом вносятся изменения в реальный DOM. 
			Поэтому - если нет необходимости - не вызывай изменения set state у родителей, чтоб лишний раз не перестраивать виртуальный DOM всех их потомков. Т.е. верхние уровни задействуем только тогда, когда это нужно

		- Какой второй аргумент может быть передан в setState? Это функция обратного вызова, вызовется когда элемент отрендерен
			Это функция обратного вызова. 
			Она реализовывается строго после setState, когда элемент отрендерен, и является полностью опциональной. 
			Рекомендуется отдать предпочтение другому методу, нежели данной функции, но знать о ее существовании и принципе работы не помешает:
				
			this.setState(
			  { username: 'tylermcginnis33' },
			  () => console.log('setState has finished and the component has re-rendered.')
			)

	- controlled и uncontrolled - контролируемые, не контролируемые компоненты. Работают со state/ работают напрямую с виртуальным DOM, обычно через ref.
		Контролируемые компоненты работают через state, получают и пишут данные обычно в state. 
		Неконтролируемые компоненты работают напрямую с виртуальным DOM деревом, обычно через ссылку ref. 
		Дух React делает упор на контролируемых компонентах. 
		+
		В HTML элементы формы, такие как input, textarea и select, как правило, поддерживают свое собственное состояние и обновляют его на основе пользовательского ввода. Когда пользователь отправляет форму, значения из элементов, упомянутых выше, отправляются вместе с формой. 
		В React это работает по-другому. 
		Компонент, содержащий форму, будет отслеживать значение ввода в своем состоянии и повторно визуализировать компонент каждый раз, когда вызывается функция обратного вызова onChange, например, при обновлении состояния. 
		Элемент ввода формы, значение которого контролируется React, таким образом называется «контролируемым компонентом».

	- PureComponent - автоматически проверяет, должен ли компонент обновляться. Не нужно писать shouldComponentUpdate самостоятельно.
		PureComponent будет вызывать функцию render(), только если обнаруживает изменения в props или в состоянии. 
		В некоторых случаях React.PureComponent более эффективен и определенно уменьшает количество кода.

		Если в props вы передаёте объекты которые иногда мутируются, т.е. по ссылке они равны ===, но внутри какие-то данные поменялись (что само по себе выглядит странно в экосистеме redux + reselect, но вполне возможно технически), тогда использование PureComponent вам всё поломает, т.к. на экране какие-то компоненты перестанут перерисовываться!

		Если же у вас всё по уму, данные которые передаются через props являются скалярными типами (string, int, float, bool) или immutable объектами, тогда смело используйте PureComponent - в некоторых случаях он поможет избавиться от лишних вызовов render.

		Важное замечание: PureComponent нужно использовать только для так называемых presentational components, т.е. для тех компонент, которые НЕ обёрнуты в вызов redux connect().

		Для container components (т.е. тех компонент, которые обёрнуты в redux connect()) нет смысла наследоваться от PureComponent, т.к. метод connect() оборачивает ваш компонент своей реализацией shouldComponentUpdate, которая также использует shallowEqual. Если вы по недосмотру унаследуете container component от PureComponent - ошибок не будет, но это не имеет никакого смыла, т.к. ваш код по сути будет дважды делать shallowEqual, а зачем делать лишнюю работу?

		По сути, вариант реализации метода shouldComponentUpdate - поверхностно сравниваются все старые/новые property и все старые/новые state. Если хоть что-то поменялось - перерисовываем компонент

		Подводя итог, рецепт такой:
			- presentational components наследуем от React.PureComponent
			- container components (которые обёрнуты в redux connect()) наследуем от старого доброго React.Component 

		Важно помнить, что PureComonent пропускает отрисовку не только самого компонента, но и всех его “детей”, так что безопаснее всего применять его в presentational-компонентах, без “детей” и без зависимости от глобального состояния приложения. 
		В случае, если pure-компонент имеет детей, все дочерние компоненты, зависящие от смены контекста, не будут реагировать на изменения, если в родительском pure-компоненте не будет объявлен contextTypes.


ЖИЗНЕННЫЙ ЦИКЛ КОМПОНЕНТА 
	
	- Ссылки
		Схема - http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
		https://metanit.com/web/react/2.6.php
		https://learn-reactjs.ru/reference/react-component
		https://reactjs.org/docs/react-component.html
	
	- Методы, которые React вызывает при разных событиях из жизни компонента (появление, удаление...)
		Каждый компонент имеет несколько «методов жизненного цикла», 
		Можно переопределить методы для запуска кода в определённое время в процессе работы приложения.

	- Если в названии есть префикс 
		- will 	 - вызываются прямо перед тем, как что-то происходит, 
		- did  	 - вызываются сразу после того, как что-то происходит.
		- should - должен

	1 Монтирование - вызываются, когда экземпляр компонента создаётся и вставляется в DOM (4)
	    - constructor() 		- конструктор, в котором происходит начальная инициализация компонента
    	 	Если вы не инициализируете состояние и не привязываете методы, вам не нужно реализовывать конструктор для вашего компонента React.
			Конструктор компонента React вызывается до его монтирования. При реализации конструктора подкласса React.Component вы должны вызвать super(props) перед любым другим оператором. В противном случае this.props не будет определен в конструкторе, что может привести к ошибкам.
			Как правило, в React конструкторы используются только для двух целей:
			    Инициализация локального состояния путем присвоения объекта this.state.
			    Привязка методов-обработчиквов событий к экземпляру.
			Вы не должны вызывать setState() в constructor(). Вместо этого, если вашему компоненту нужно использовать локальное состояние, присвойте начальное состояние this.state непосредственно в конструкторе
	    - componentWillMount()  - УСТАРЕВШИЙ! непосредственно перед рендерингом компонента
			- часто используется для получения данных (отправка запроса за статьёй на сервер и т.д.)
			.
	    - render() 				- рендеринг компонента
				- чистый, не пихать сюда ничего. Только для того, чтобы строить виртуальный DOM компонента
				.
	    - componentDidMount() 	- после рендеринга компонента. Здесь можно выполнять запросы к удаленным ресурсам 
			- реагируем на появление компонента в реальном DOM. 
			- Например получить размеры, позиционирование, подписаться на изменение данных, повесить свои listener на DOM-элементы...

	2 Обновление - когда компонент повторно перерисовывается. Может быть вызвано изменениями в свойствах или состоянии
	    - componentWillReceiveProps() - при обновлении props, до монтирования новых. Здесь надо обновлять state компонента из приходящих props
		    	Тут приходят новые props.
		    	Вызывается до монтирования новых пропсов в компонент.
		    	Обычно в этой функции устанавливаются свойства компонента (в том числе из this.state), которые зависят от значений из пришедших в компонент props
				- React передаёт новые props, которые можно сравнить с текущими. Вызывается только если поменялся кто-то из родителей и буду меняться какие-то props. Два основных варианта использования:
				- поменялись важные данные и надо отреагировать. Например пришла новая статья и надо загрузить её с сервера
				- мы завязали состояние компонента на porps (не лучшая практика, но иногда оптимальная) - теперь надо следить за изменениями в props, и приводить state к нужному виду. Например, состояние статьи (свёрнута/развёрнута) приходят в компонент из другого компонента, через props. Тогда надо отслеживать -изменились ли эти props, и перерисовывать состояния статьи
	    - shouldComponentUpdate() 	  - каждый раз при обновлении объекта props или state
	    		- позволяет оптимизировать приложение в ручном режиме, управляя тем, нужно ли перестраивать виртуальный DOM для этого компонента или нет?
	    		- т.е. позволяет оптимизировать перерисовку виртуального DOM - если в это компоненте ничего не поменялось, не перерисовываем 
	    		- Вызывается при изменении родителей, и при смене setState в самом компоненте.
	    		- Не забывать, про сравнение ссылочных типов. Не должно быть мутации данных
				    - Каждый раз, когда меняются данные, должна создаваться новая ссылка.
				    	либо заменяем все мутабельные операции на аналогичные иммутабельные операции, 
				    	либо создаем новую ссылку и затем уже её мутируем.
				    - Новая ссылка должна создаваться только тогда, когда меняются данные.

				https://www.youtube.com/watch?v=Jw1zocLDnnc (10. Оптимизация приложений, shouldComponentUpdate)
		- componentWillUpdate() 	  - УСТАРЕВШИЙ! перед обновлением компонента (если shouldComponentUpdate возвращает true)
		- render()
		- componentDidUpdate() 		  - сразу после обновления компонента (если shouldComponentUpdate возвращает true

		Эти методы считаются устаревшими, и вам следует избегать их в новом коде:
		    UNSAFE_componentWillUpdate()
		    UNSAFE_componentWillReceiveProps()


		Обновление - произошёл setState внутри компонента, или он произошёл у кого-то из родителей
			- componentWillReceiveProps(nextProps) 

			- shouldComponentUpdate(nextProps, nextState) 
					
					- предупреждает, что сейчас будем перестраивать виртуальный DOM этого компонента. 
					Можно отреагировать на изменения - загрузить текст для статьи, которая открывается и т.д.  Вызывается и при изменении родителей, и при смене setState  в самом компоненте.
			- render() 
					- чистый, не пихать сюда ничего. 
					Только для того, чтобы строить виртуальный DOM компонента
			- shouldDidUpdate(prevProps, prevState) 
					- чаще всего нужен, если нас интересуют составляющие реального DOM (размер компонента, позиционирование...)

		Обновление компонентов: 
			использовать метод shouldComponentUpdate, 
			А лучше, при создании компонента, наследовать его от компонента PureComponent - тогда сравниваются ВСЕ props (старые и новые) и ВСЕ элементы state (старые и новые). 
			Т.е. не надо каждый раз объявлять «отслеживай ещё изменения этого параметра» — он будет следить по-умолчанию. 
			Но, без необходимости лучше не использовать — могу вылезти сложные баги
		    
		    import React, {Component, PureComponent} from 'react';
		    class Article extends PureComponent {
		      ...
		    }

	3 Демонтирование - когда компонент удаляется из DOM (1)
		- componentWillUnmount() 	  - перед удалением компонента из DOM. Подчищаем подписки, проводим логику деструктуризации компонента
	    	предупреждает что компонент будет удалён. 
			Например, остановить и обнулить таймер

	4 Обработка ошибок - при возникновении ошибки (1)
		- componentDidCatch()
			Вызывается при ошибках:
				ошибки во время отрисовки
				ошибки в методе жизненного цикла
				ошибки в конструкторе любого дочернего компонента.

	I. Другие API - каждый компонент также предоставляет некоторые другие API:
		- setState()
		- forceUpdate()

	II. Свойства класса
	    - defaultProps
	    - displayName

	III. Свойства экземпляра
	    - props
	    - state

	- ComponentDidMount()
		- происходит один единственный раз - при отрисовке компоненты на странице. При обновлении - не вызывается.
		- Все сайд-эффекты делать в ComponentDidMount() Например, там вызываются запросы на сервак, AJAX-запросы, setTimeout и все манипуляции с DOOM

	- ComponentDidUpdate
		- при обновлении


ХУКИ REACT 
	- https://ru.reactjs.org/docs/hooks-intro.html
	
	- Хук — функция, с помощью которой можно «подцепиться» к state и методам жизненного цикла React из функц. компонент. Не работает в  классах. 

	- React содержит несколько встроенных хуков, таких как useState. Можно создавать собственные хуки, чтобы повторно использовать их в других компонентах.

	- Хуки следует вызывать только на верхнем уровне. Не вызывайте хуки внутри циклов, условий или вложенных функций.

	- Хуки следует вызывать только из функциональных компонентов React. 
		Не вызывайте хуки из обычных JavaScript-функций. 
		Есть только одно исключение, откуда можно вызывать хуки — это ваши пользовательские хуки. Мы расскажем о них далее.

	- Хуки — это способ использовать повторно логику состояния, а не само состояние. 
		Каждое обращение к хуку обеспечивает совершенно изолированное состояние. 
		Вы даже можете использовать один и тот же хук несколько раз в одном компоненте.

	- Пользовательские хуки — функция, имя которой начинается с «use», и которая может вызывать другие хуки.
		https://ru.reactjs.org/docs/hooks-custom.html

	- Пример хука состояния (useState)
		https://ru.reactjs.org/docs/hooks-state.html

		import React, { useState } from 'react';

		function Example() {
		  // Объявление новой переменной состояния «count»
		  const [count, setCount] = useState(0);

		  return (
		    <div>
		      <p>Вы кликнули {count} раз(а)</p>
		      <button onClick={() => setCount(count + 1)}>
		        Нажми на меня
		      </button>
		    </div>
		  );
		}


		Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние. 
		Поэтому мы пишем const [count, setCount] = useState(). 
		Это похоже на this.state.count и this.setState в классах, с той лишь разницей, что сейчас мы принимаем их сразу в паре. 

		В классовой компоненте это выглядело бы так:
			class Example extends React.Component {
			  constructor(props) {
			    super(props);
			    this.state = {
			      count: 0
			    };
			  }

			  render() {
			    return (
			      <div>
			        <p>Вы кликнули {this.state.count} раз(а)</p>
			        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
			          Нажми на меня
			        </button>
			      </div>
			    );
			  }
			}

	- Про квадратные скобки, две переменных и деструктуризацию:
		const [fruit, setFruit] = useState('банан');

		Такой синтаксис в JS называется «деструктуризацией массивов (array destructuring)». 
		Он означает, что мы создаём две новые переменные, fruit и setFruit. 
		Во fruit будет записано первое значение, вернувшееся из useState, а в setFruit — второе. 

		Это равносильно такому коду:
			var fruitStateVariable = useState('банан'); // Возвращает пару значений
			var fruit = fruitStateVariable[0]; // Извлекаем первое значение
			var setFruit = fruitStateVariable[1]; // Извлекаем второе значение

	  	Когда мы объявляем переменную состояния с помощью функции useState, мы получаем от неё пару, то есть массив из двух элементов. Первый элемент обозначает текущее значение, а второй является функцией, позволяющей менять это значение. 

	- Чтоб прочитать state из хука мы используем переменную, которую ранее объявили
		Например:
			<p>Вы кликнули {count} раз(а)</p>

		В классовой	компоненте это было бы так: 
			<p>Вы кликнули {this.state.count} раз(а)</p>

	- Чтобы обновить state:
		  <button onClick={() => setCount(count + 1)}>
		    Нажми на меня
		  </button>

		  В классовой компоненте это было бы так:
			<button onClick={() => this.setState({ count: this.state.count + 1 })}>
			    Нажми на меня
		  	</button>

  	- В отличие от this.setState в классах, обновление переменной состояния всегда замещает её значение, а не осуществляет слияние.

  	- Поскольку хуки являются функциями, мы можем передавать информацию между ними.


РОУТИНГ
	http://bogdanov-blog.ru/react-router-v4-notes/
	https://habrahabr.ru/post/329996/

	- React-Router - набор компонентов определяющих на основе текущего пути, какой компонент будет выводиться.

	- react-router - пакет с базовым набором функций

	- router-dom - пакет с набором функций для работы в браузере

	- BrowserRouter и HashRouter - для браузерных проектов есть BrowserRouter и HashRouter компоненты. 
		BrowserRouter — следует использовать когда вы обрабатываете на сервере динамические запросы. Если проект предполагает бекенд - бери BrowserRouter.
		HashRouter - когда у вас статический веб сайт.

		Обычно предпочтительнее использовать BrowserRouter, но если ваш сайт расположен на статическом сервере(как github pages), то использовать HashRouter это хорошее решение проблемы.

	- <Route/> - компонент, строительный блок React Router'а. 
		Если вам нужно рендерить элемент в зависимости от pathname URL'ов, то следует использовать компонент <Route/>

	- Route и NavLink = два независимых элемента. 
		Фактически, это обычные компоненты, написанные разработчиками, и подключаемые из билиотеки. В них передаются параметры и функции. ПРи наступлении условия X сделай то-=то (например, отрисуй компоненту такую-то) 
	    Route - меняет содержимое страницы, в зависимости от того, что введено в адресной строке. Следит за ней, и при изменениии - отрабатывает
	    NavLink - при клике меняет адрес в адресной строке


СТРОГАЯ ТИПЗАЦИЯ
	- Type Script - язык, Microsoft
		- язык разработанный Microsoft. Совместим с JS (расширяет его). Добавляет возможности статической типизации и ООП.

		- представляет собой надмножество, которое компилируется в JavaScript — хотя по ощущениям TypeScript похож на новый язык со статической типизацией сам по себе. То есть очень похож на JavaScript и не сложен в освоении.

		- есть аналогичное решение от Facebook - Flow.

		- в Angular разработка ведётся на TypScript

		- При статической типизации мне необязательно напоминать компилятору, что данная переменная, например, целое число, и всегда должно им оставаться. 
			Эта информация хранится в программе, и даже если я, забывшись, попытаюсь изменить ее значение на недопустимое, ничего страшного не произойдет.
			Примеры: C, C++, C#, Java, Pascal...
			Динамическая типизация - Perl, Ruby, JavaScript, Lisp, PHP, Python...
		
		- Статические языки производительнее.

		- Статические языки - с помощью тестирования типов легко проверить работоспособность кода еще до его выполнения. 

		- Эффективность. Статическая типизация требует от программиста большей ответственности. Динамические языки, в свою очередь, могут поощрять некоторую раскованность, вырабатывая у разработчика привычку следовать дурным паттернам.

		- Динамический пример на JS
			var name = "Susan",
				age = 25,
				hasCode = true;

		- Статический пример на TypeScript
			let name: string = "Susan",
				age: number = 25,
				hasCode: boolean = true;

	- Flow - библиотека, Facebook
		open source библиотека для статической проверки типов, которую разработала и выпустила Facebook. 
		Позволяет постепенно добавлять типы в ваш код JavaScript.
		Flow представляет собой инструмент статического анализа, который использует надмножество языка, позволяя добавлять аннотации типов к ко всему вашему коду и улавливать весь класс ошибок во время компиляции.

	- В каждом случае если вы хотите использовать типы, то явно говорите инструменту, в каких файлах осуществлять проверку типов. 
		В случае TypeScript вы делаете, создавая файлы с расширением .ts вместо .js. 
		В случае Flow вы указываете в начале кода комментарий @flow.

	- PropTypes
		- изначально был в составе React, потом вынесли в отдельную библиотеку
		- функциональность намного меньше и проще, чем у TS/Flow
		- проверяет только props
		- выдаёт предупреждения об ошибках типов во время запуска

		- PropTypes может давать вам предупреждения во время выполнения, что может быть полезно для быстрого поиска неверных ответов, поступающих с сервера, и т.

		- В существующих приложениях с большими объектами, это быстро приведет к большому количеству кода. Это проблема, так как в Реакте часто нужно передавать один и тот же объект множеству компонентов. Повторение этого процесса во множестве компонентов нарушает принцип DRY (Don’t Repeat Yourself). Самоповторы приводят к проблемам с поддержкой.

		-  Проблема с использованием PropTypes вместе с Flow заключается в том, что вы пишете много дубликатов кода. Оба определения в основном содержат ту же информацию, и когда тип данных изменяется, необходимо обновить оба определения.

		- propTypes - специальное свойство класса компонента (так было раньше?). Задают типы входных параметров для отрисовываемого компонента.
			https://habr.com/ru/post/319358/
			В случае несовпадения (например вместо числа пришла строка) позволяют получить ошибку в react-dev-tools и отловить этот момент во время выполнения. 
			Это была встроенная возможность контроля типов для больших приложений, но с недавнего времени вынесена в отдельный пакет. 
			Для некоторых приложений, вы можете использовать расширения JavaScript такие как Flow или TypeScript осуществляя проверку типов всего вашего приложения. Но если вы не используете таковые — React предоставляет некоторые встроенные возможности проверки типов.

			Пример:
			class Greeting extends React.Component {
			  render() {
			    return (
			      <h1>Hello, {this.props.name}</h1>
			    );
			  }
			}

			Greeting.propTypes = {
			  name: React.PropTypes.string
			};

			- В целях производительности, propTypes проверяются только в режиме разработки (development). Т.е. сам код остаётся, но не проверяется. Для удаления кода есть спец. модуль

	- Различия PropTypes и Flow
		Flow - почти язык
		PropTypes - едва ли библиотека

		Кроме того, что и PropTypes и Flow  относятся к очень широкому полю проверки типов, между ними нет особого сходства.
		Flow представляет собой инструмент статического анализа, который использует надмножество языка, позволяя добавлять аннотации типов к ко всему вашему коду и улавливать весь класс ошибок во время компиляции.

		- PropTypes - это базовая проверяльщик типов, который был частью React. 
		Он не может проверять ничего, кроме типов props, передаваемого данному компоненту.

		Если вам нужен более гибкий метод проверки типов для всего проекта, то Flow/TypeScript являются подходящими. 
		Пока вы передаете только аннотированные типы в компоненты, вам не понадобятся PropTypes.

		Если вы просто хотите проверить типы props, не делайте излишнюю усложнение остальной части своей кодовой базы и идите с более простой опцией.

		- Flow - инструмент статического анализа 
		- PropTypes - инструмент проверки во время запуска. Теоретически может отловить ошибки, которые могут быть пропущены Flow


AJAX, JSON, CORS и т.д.

	- https://clck.ru/GUCaN


	- порт — это номер, который, выдаёт операционная система каждой программе, которая хочет отослать данные в сеть

	- TCP/IP - сетевая модель передачи данных, представленных в цифровом виде. 
		T.е. теоретическое описание принципов работы набора сетевых протоколов, взаимодействующих друг с другом. 
		
		В модели предполагается прохождение информации через четыре уровня, каждый из которых описывается правилом (протоколом передачи). Наборы правил, решающих задачу по передаче данных, составляют стек протоколов передачи данных, на которых базируется Интернет[1][2]. 

		Название TCP/IP происходит из двух важнейших протоколов семейства — Transmission Control Protocol (TCP) и Internet Protocol (IP), которые были первыми разработаны и описаны в данном стандарте. 


		В протоколе Ethernet находятся номер сетевого адаптера отправителя (MAC-адрес), номер сетевого адаптера получателя, тип передаваемых данных и непосредственно передаваемые данные. Порция информации, составленная в соответствии с протоколом Ethernet, называется кадром. Считается, что сетевых адаптеров с одинаковым номером не существует. Сетевое оборудование извлекает передаваемые данные из кадра (аппаратно или программно), и производит дальнейшую обработку.

		Как правило, извлечённые данные в свою очередь сформированы в соответствии с протоколом IP и имеют другой вид идентификационной информации — ip адрес получателя (число размером в 4 байта), ip адрес отправителя и данные. А так же много другой необходимой служебной информации. Данные, сформированные в соответствии с IP протоколом, называются пакетами.

		Далее извлекаются данные из пакета. Но и эти данные, как правило, ещё не являются изначально отправляемыми данными. Этот кусок информации тоже составлен в соответствии определённому протоколу. Наиболее широко используется TCP протокол. В нём содержится такая идентификационная информация, как порт отправителя (число размером в два байта) и порт источника, а так же данные и служебная информация. Извлечённые данные из TCP, как правило, и есть те данные, которые программа, работающая на компьютере В, отправляла «программе-приёмнику» на компьютере A.

		Вложенность протоколов (в данном случае TCP поверх IP поверх Ethernet) называется стеком протоколов.

		Фактически TCP/IP не один протокол, а несколько. Именно поэтому вы часто слышите, как его называют набором, или комплектом протоколов, среди которых TCP и IP - два основных. 

		https://habr.com/ru/post/326574/
		https://ru.wikipedia.org/wiki/TCP/IP

	- HTTP - протокол передачи данных
		HyperText Transfer Protocol, «протокол передачи гипертекста»

		Протокол прикладного уровня (верхний 7-й уровень модел OSI) предназначенный для передачи произвольных данных при клиент-серверном взаимодействии.

		предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.

		HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как SOAP, XML-RPC и WebDAV. В таком случае говорят, что протокол HTTP используется как «транспорт».

		API многих программных продуктов также подразумевает использование HTTP для передачи данных — сами данные при этом могут иметь любой формат, например, XML или JSON.

		Как правило, передача данных по протоколу HTTP осуществляется через TCP/IP-соединения.

		- HTTPS - распространённое расширение HTTP, которое реализует упаковку передаваемых данных в криптографический протокол SSL или TLS.
		
		Методы HTTP-протокола:
			Метод — это указание операции над ресурсом.
		    - GET — получение данных с ресурса. Не имеет тела, информацию можно передать только через querystring. Кэшируется.
		    - HEAD — как GET но не возвращает данных. Используют для проверки существования сайта, получения метаданных. Кэшируется.
		    - POST — отправка данных к ресурсу. Не кэшируется.
		    - PUT — замещение данных ресурса. Не кэшируется.
		    - DELETE — удаление данных ресурса. Не кэшируется.
		    - OPTIONS — предварительный запрос к серверу при кросс-доменном запросе. Не кэшируется (???).

		https://habr.com/ru/post/215117/

	- JSON (Javascript Object Notation) - формат данных, который используется для представления объектов в виде строки.
		Если нужно с сервера взять объект с данными и передать его клиенту, то в качестве промежуточного формата – для передачи по сети, почти всегда используют именно его.

		Данные в формате JSON (RFC 4627) представляют собой:
		    - JS-объекты { ... } или
		    - Массивы    [ ... ] или
		    - Значения одного из типов:
		        - строки в двойных кавычках,
		        - число,
		        - логическое значение true/false,
		        - null.

		https://learn.javascript.ru/json

 	- AJAX - технология отправки запросов к серверу из клиентского кода JavaScript без перезагрузки страницы.
  		https://learn.javascript.ru/ajax
  		https://habr.com/ru/post/14246/

  		Расшифровывается как Asynchronous JavaScript And XML. 
  		Сейчас вместо чаще XML используют формат JSON.
  		Слать AJAX-запросы к серверам с другим доменом запрещено на уровне браузера. Ajax не кроссдоменный, но подходит много для каких задач.
  		Асинхронный
  		Браузер предоставляет для AJAX специальный API: конструктор XMLHttpRequest
  		AJAX работает через XMLHttpRequest (XMLHTTP, XHR), т.е. через запросы HTTP/HTTPS 
  		Т.е. асинхронный обмен данными (JSON/XML/TXT) через HTTP/HTTPS запросы

  		При использовании AJAX:
		    - Пользователь заходит на веб-страницу и нажимает на какой-нибудь её элемент.
		    - Скрипт (на языке JavaScript) определяет, какая информация необходима для обновления страницы.
		    - Браузер отправляет соответствующий запрос на сервер.
		    - Сервер возвращает только ту часть документа, на которую пришёл запрос.
		    - Скрипт вносит изменения с учётом полученной информации (без полной перезагрузки страницы).

  		AJAX использует два метода работы с веб-страницей: 
  			- изменение Web-страницы без перезагрузки, используя DHTML (совокупность технологий CSS, DOM и JavaScript)
  			- динамическое обращение к серверу. Может осуществляться несколькими способами, в частности, XMLHttpRequest, и использование техники скрытого фрейма.

		Алгоритм запроса к серверу выглядит так:
		    - Проверка существования на странице объекта XMLHttpRequest. Создание данного объекта для каждого типа браузера — уникальный процесс.
		    - Инициализация соединения с сервером.
		    - Посылка запроса серверу (GET или POST)
		    - Обработка полученных данных.

    	От сервера можно получить данные нескольких видов:
		    - Обычный текст
		    - XML
		    - JSON

	    Альтернативы AJAX:
		    - Java-апплеты, позднее технология JavaFX;
		    - Технология Silverlight корпорации Microsoft;
		    - Протокол WebSocket.

	- JSONP (JSON with Padding, JSON с набивкой) - протокол. Дополнение к формату JSON. Способ запросить данные с сервера, находящегося в другом домене.
		Не имеет отношения к AJAX
		Устаревший но хитрый способ двунаправленного кроссдоменного взаимодействия, основанный на загрузке скрипта с другого домена.
		В частности, с помощью протокла JSONP можно организовать некоторые разновидности технологии COMET. 
		Насколько я понимаю, работает также с использование XMLHttpRequest, т.е. поверх HTTP/HTTPS

		Согласно политике ограничения домена, веб-страница, расположенная на сервере server1.example.com, не может связаться с сервером, отличным от server1.example.com. Эта операция запрещена в большинстве браузеров.

		Идея основана на лазейке в стандартах: загружать скрипты с других доменов не запрещено! 

		В основу технологии JSONP положен тот факт, что политика безопасности браузера не запрещает использовать HTML-элемент <script type="text/javascript" src="…"/> для обращения к серверам, отличным от сервера, с которого произошла загрузка страницы. Используя открытую политику для элементов <script>, некоторые страницы используют их, чтобы загружать JavaScript-код, оперирующий динамически создаваемыми JSON-данными из других источников. 

		Запросы для JSONP получают не JSON, а произвольный JavaScript-код. Они обрабатываются интерпретатором JavaScript, а не парсером JSON.

		Существуют серьезные риски, связанные с безопасностью при использовании JSONP, в большинстве ситуаций использование CORS является лучшим выбором.

		JSONP кроссдоменный, но подходит только для случаев, когда надо кроссдоменно передать JSON.

		Набивка (префикс) 
			Набивка обычно является именем функции обратного вызова, определённой внутри контекста выполнения в браузере. Кроме имени функции префикс может означать имя переменной, оператор if, или любой другой оператор JavaScript. Ответ на JSONP-запрос (строго говоря — запрос, соответствующий паттерну JSONP) не является объектом JSON и не расценивается браузером, как таковой. «Начинка» может быть любым выражением на JavaScript, и вовсе не требует, чтобы внутри обязательно был JSON. Но обычно это фрагмент JavaScript, применяющий вызов функции к неким JSON-данным.

			Другими словами, типичное применение JSONP предоставляет междоменный доступ к существующему JSON API путём оборачивания начинки JSON в вызов функции.

		Недостатки
			- Прежде всего, это лазейка, костыль. Разработчики стандартов просто не были настолько хитры, чтобы предугадать динамическое взаимодействие на уровне скриптов.

			- Безопасность. Подгрузка скриптов ни разу не безопасней, чем Аякс. Целое семейство вирусов занимается тем, что добавляет на страницу браузера скрипты для отрисовки баннеров порно и казино. Когда вы подключаетесь к интернету через мобильных операторов, обсосы вставляют в HTML-трафик скрипты для отрисовки виджетов (если соединение не HTTPS)

			- Только GET. JSONP работает только методом GET, что сводит на нет возможности REST-интерфейса. Для REST-сервисов приходится писать прокладки-прокси, т.е. множить костыли. Неустранимое ограничение — позволяет только получение данных GET методом, то есть отправка данных через POST метод остается недоступной. 

			- Нельзя отслеживать. Добавив скрипт на страницу, в дальнейшем вы не можете отследить его судьбу. Если у Аякс-запроса есть специальные коллбеки для основных событий (начало, удачное завершение, таймаут, неудачное завершение), то у скрипта ничего такого нет. Загрузился ли он? Ответил ли сервер? Была ли ошибка? Никто не знает.

		Каковы проблемы JSONP?
		    - Это вне стандартов.
		    - Это небезопасно.
		    - Если запрос провалился, то ничего мы никогда не узнаем, не обработаем ошибку правильно, не можем отследить судьбу запроса.
		    - Мы работаем только с GET — никаких модных REST API.
		    - И в общем, так делать не надо в 2017 году.

		Приложениям на js нужен надежный способ забирать данные с серверов. Чтобы это была законно, а не по-воровски в обход протоколов и стандартов. Таким способом стал CORS – Cross-Origin Resource Sharing, кросс-доменные запросы.

		https://ru.wikipedia.org/wiki/JSONP
		https://grishaev.me/cors/

	- JSONPP (англ. parameterized JSON with padding — «параметризованный JSON с подкладкой») — развитие идеи JSONP
		развитие идеи JSONP
		включает в себя URL источника, имя функции, которая будет обрабатывать JSON данные, строка для eval после получения данных и строка для eval после окончания обработки данных

	- CORS - кросс-доменные запросы. Разрешаем кросс-доменный AJAX (если сервер согласен его принять)
		Cross-origin resource sharing (англ. — «совместное использование ресурсов между разными источниками») 
		Технология современных браузеров, которая позволяет предоставить веб-странице доступ к ресурсам другого домена. Современный стандарт кроссдоменных запросов
		Слать AJAX-запросы к серверам с другим доменом запрещено на уровне браузера
		Фактически - расширение поверх AJAX

		Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. 
		Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

		Здесь: 
			- клиент шлет Аякс-запрос к чужому серверу. 
			- браузер добавляет в запрос особые заголовки с информацией о том, что запрос с другого домена. 
			- на их основании сервер решает, как обрабатывать такой запрос, и добавляет особые заголовки в ответ

		Браузер добавит заголовок Origin с адресом страницы, откуда инициирован запрос. Подделать заголовок скриптом не удастся

		Т.е. по факту я в своём приложении создаю AJAX запрос с опр. набором параметров (заголовки и т.д.), и если сервер поддерживает CORS - он пришлёт ответ

		Простые и сложные CORS-запросы
			- Сложные идут в два этапа (preflight запрос и собственно запрос). Сначала браузер делает запрос по тому же урлу, но методом OPTIONS. Сервер должен ответить: какими другими методами и дополнительными заголовками (помимо стандартных) можно обращаться к этому урлу. И только получив разрешение, браузер сделает запрос на основной урл.
			- Запрашиваешь JSON - автоматически должен использовать сложный запрос

		Поддержка браузерами
		    - Firefox 3.5 и выше
		    - Google Chrome 3 и выше
		    - Opera 12.00
		    - Safari 4 и выше
		    - Internet Explorer 
		    	8      - частичная поддержка через XDomainRequest объект. 
		    	9      - частичная поддержка через XDomainRequest объект. 
		    	10 	   - встроенная поддержка
		    	10,11  - не поддерживают CORS для интернациональных доменных имен (IDN), содержащих нелатинские символы.


		Технология CORS может быть использована как более современная и надёжная альтернатива JSONP, так как позволяет использовать все преимущества XMLHttpRequest, и не имеет риска инъекции, как JSONP. С другой стороны, технология CORS поддерживается только современными браузерами, а JSONP работает и в старых тоже. 

		Механизм CORS поддерживает кросс-доменные запросы и передачу данных между браузером и web-серверами по защищенному соединению. 
		Современные браузеры используют CORS в API-контейнерах, таких как XMLHttpRequest или Fetch, чтобы снизить риски, присущие запросам с других источников.

		https://grishaev.me/cors/
		https://ru.wikipedia.org/wiki/Cross-origin_resource_sharing
		https://developer.mozilla.org/ru/docs/Web/HTTP/CORS

  	- COMET – общий термин, описывающий различные техники получения данных по инициативе сервера.
		Методика отправки данных по инициативе сервера, разработанная поверх AJAX.
		
		Можно сказать, что AJAX – это «отправил запрос – получил результат», а COMET – это «непрерывный канал, по которому приходят данные».
		COMET можно реализовать по протоколу JSONP. Можно и иначе 
		COMET - методика отправки данных по инициативе сервера, разработанная поверх AJAX.

		Примеры COMET-приложений:
		    - Чат – человек сидит и смотрит, что пишут другие. Новые сообщения приходят «сами по себе», не надо жать кнопку для обновления окна.
		    - Аукцион – человек смотрит на экран и видит, как обновляется текущая ставка за товар.
		    - Интерфейс редактирования – когда один редактор начинает изменять документ, другие видят информацию об этом. Совместное редактирование.

		Какие API предоставляет браузер для взаимодействия COMET?
			- SSE (server-side events) API — события посылаемые сервером — однонаправленное HTTP-подключение к серверу. Поддерживают короткие запросы, длинные запросы, потоковое подключение к серверу.
			- Web Sockets API — двунаправленное взаимодействие с сервером. Работает по собственному протоколу.

	    Страница не просто разово или циклично запрашивает контент с сервера, а создает с сервером постоянное HTTP-соединение и ждет от него передачи данных. Это позволяет пользователям веб-приложения более оперативно получать все возникающие на сервере события (пример - мгновенное уведомление о новом сообщении в социальных сетях). 
	    В идеальном варианте для этого на сервере разворачивается специальное программное обеспечение, сам сервер особым образом конфигурируется, а на клиентской части используются специальные библиотеки для обмена данными. Это если рассматривать использование COMET в контексте больших и серьезных проектов. Для рядового сайта, размещенного на обычном хостинге с ограничением времени исполнения скрипта, можно сделать облегченный аналог COMET.

	    - polling
	    	Использование периодических запросов к серверу через AJAX. Например, скрипт из браузера каждые 5 секунд отправляет запрос на серверный скрипт и запрашивает количество новых непрочитанных сообщений. 
	    	Можно дополнительно снизить нагрузку на сервер путем снижения частоты отсылаемых запросов, но это опять же пойдет в ущерб актуальности данных и в разрез с условием задачи о мгновенном информировании пользователя о письме.

	    - long polling (это вариант реализации COMET) 
	    	Есть несколько вариантов реализации, но, к сожалению, практически все они завязаны на конкретном браузере и ведут себя по-своему. 
	    	Единственным кроссбраузерным и гарантированно работающим решением является так называемая "очередь длинных запросов", или "long polling". 

	    	Сначала браузер отправляет AJAX-запрос на сервер и ожидает ответа. Соединение остается открытым до тех пор, пока на сервере не наступит ожидаемое событие (или, как в нашем случае, пока серверный скрипт не отвалится по таймауту). Сразу после наступления события данные отправляются в браузер и соединение закрывается. Браузер после получения данных сразу же открывает новое соединение и все повторяется. 

	    	Это очень похоже на предыдущий способ "polling", но данные с сервера передаются с максимально возможной актуальностью. Если за время ожидания никаких событий на сервере не случилось, интервал между "долгими" запросами будет гораздо больше, чем при долбежке сервера периодическими опросами. Поэтому еще более минимизируются расходы на передачу заголовков запросов, тем самым еще больше снижается нагрузка на сервер.

	- WebSocket - протокол для пересылки любых данных, на любой домен, безопасно и почти без лишнего сетевого трафика. Замена AJAX. 
		Один из API браузера, который он предоставляет чтоб реализовать COMET. 
		Альтернатива - SSE (server-side events) API.
		
		WebSocket - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени. 
		Предназначен для решения любых задач и снятия ограничений обмена данными между браузером и сервером.
		независимый протокол, основанный на протоколе TCP
		Не стоит использовать веб-сокеты в REST API, поскольку вам хватит таких HTTP-запросов, как GET, POST, DELETE и PUT.
		В отличие от CORS работает вообще без AJAX, отдельный протокол, даже на HTTP

		Протокол WebSocket работает над TCP& также как и HTTP. Т.е. на том же уровне, что и HTTP, заменяет его, а не "поверх него"
		AJAX работает на HTTP
		Это означает, что при соединении браузер отправляет по HTTP специальные заголовки, спрашивая: «поддерживает ли сервер WebSocket?».
		Если сервер в ответных заголовках отвечает «да, поддерживаю», то дальше HTTP прекращается и общение идёт на специальном протоколе WebSocket, который уже не имеет с HTTP ничего общего.

		Соединение WebSocket можно открывать как WS:// или как WSS://. Протокол WSS представляет собой WebSocket над HTTPS.
		Кроме большей безопасности, у WSS есть важное преимущество перед обычным WS – большая вероятность соединения.
		Дело в том, что HTTPS шифрует трафик от клиента к серверу, а HTTP – нет.
		Если между клиентом и сервером есть прокси, то в случае с HTTP все WebSocket-заголовки и данные передаются через него. Прокси имеет к ним доступ, ведь они никак не шифруются, и может расценить происходящее как нарушение протокола HTTP, обрезать заголовки или оборвать передачу.
		А в случае с WSS весь трафик сразу кодируется и через прокси проходит уже в закодированном виде. Поэтому заголовки гарантированно пройдут, и общая вероятность соединения через WSS выше, чем через WS.

		WebSocket поддерживается в следующих браузерах:
		    Google Chrome (начиная с версии 4.0.249.0);
		    Apple Safari (начиная с версии 5.0.7533.16);
		    Mozilla Firefox (начиная с версии 4);
		    Opera (начиная с версии 10.70 9067);
		    Internet Explorer (начиная с версии 10);

		    Проверить поддержку браузером WebSocket можно, пройдя по ссылке: http://caniuse.com/#feat=websockets. 

	    Это сдвиг парадигмы HTTP. Изначально синхронный протокол, построенный по модели «запрос — ответ», становится полностью асинхронным и симметричным. Теперь уже нет клиента и сервера с фиксированными ролями, а есть два равноправных участника обмена данными. Каждый работает сам по себе, и когда надо отправляет данные другому. Отправил — и пошел дальше, ничего ждать не надо. Вторая сторона ответит, когда захочет — может не сразу, а может и вообще не ответит. Протокол дает полную свободу в обмене данными, вам решать как это использовать.

	    Как только ваша страница решила, что она хочет открыть веб сокет на сервер, она создает специальный javascript-объект WebSocket  и навешивает на новый объект три колл-бека:
	    	- первый вызовется, когда соединение будет установлено:
	    	- второй - когда соединено закроется
	    	- третий - каждый раз, когда браузер получает какие-то данные через веб-сокет
     	Браузер подключается по протоколу TCP на 80 порт сервера и дает немного необычный GET-запрос
     	Если сервер поддерживает ВебСокеты, то он отвечает опр. образом
     	Если браузер это устраивает, то он просто оставляет TCP-соединение открытым. Все — «рукопожатие» совершено, канал обмена данными готов.
     	Как только одна сторона хочет передать другой какую-то информацию, она отправляет дата-фрей. Это просто строка текста — последовательность байт. Никаких заголовков, метаданных! Что именно отправлять, разработчики полностью оставили на ваше усмотрение: хотите XML, хотите JSON, да хоть стихи Пушкина.
     	Каждый раз, когда браузер будет получать такое сообщение, он будет «дергать» ваш колл-бек onmessage. 

     	Легко понять, что КПД такого протокола стремится к 95%. Это не классический AJAX-запрос, где на каждую фитюльку приходится пересылать несколько килобайт заголовков. Разница будет особенно заметна если делать частый обмен небольшими блоками данных. Скорость обработки так же стремится к скорости чистого TCP-сокета — ведь все уже готово — соединение открыто — всего лишь байты переслать.

     	в качестве единственной разрешенной кодировки выбрана UTF-8

     	А картинку можно отправить? Да. С помощью WebSockets так же можно передавать и бинарные данные. Для них используется другой дата-фрейм опр. вида

		Скорость и эффективность
			Высокую скорость и эффективность передачи обеспечивает малый размер передаваемых данных, который иногда даже будет помещаться в один TCP-пакет — здесь, конечно, же все зависит от вашей бизнес-логики. 
			Так же учтите, что соединение уже готово — не надо тратить время и трафик на его установление, хендшейки, переговоры.

		Стандартность
			Самим своим выходом WebSockets отправит на свалку истории Comet и все приблуды накрученные поверх него — Bayuex, LongPolling, MultiPart и так далее. Это все полезные технологии, но по большей части, они работают на хаках, а не стандартах. Отсюда периодески возникают проблемы

     	Время жизни канала
			В отличие от HTTP веб-сокеты не имеют ограничений на время жизни в неактивном состоянии. Это значит, что больше не надо периодически рефрешить соединение, т.к. его не вправе «прихлопывать» всякие прокси. Значит, соединение может висеть в неактивном виде и не требовать ресурсов. Конечно, можно возразить, что на сервере будут забиваться TCP-сокеты. Для этого достаточно использовать хороший мультиплексор, и нормальный сервер легко потянет до миллиона открытых коннектов.

		Комплексные веб-приложения
			Как известно в HTTP предусмотрено ограничение на число одновременных октрытых сессий к одному серверу. Из-за этого если у вас много различных асинхронных блоков на странице, то вам приходилось делать не только серверный, но и клиентский мультиплексор — именно отсюда идет Bayeux Protocol.
			К счастью, это ограничение не распространяется на веб-сокеты. Открываете столько, сколько вам нужно. А сколько использовать — одно (и через него все мультиплексировать) или же наоборот — на каждый блок свое соединение — решать вам. Исходите из удобства разработки, нагрузки на сервер и клиент.

		Кросс-доменные приложения
			И еще один «камень в ботинке» AJAX-разработчика — проблемы с кросс-доменными приложениями. Да, и для них тоже придумана масса хаков. Помашем им ручкой и смахнем скупую слезу. WebSockets не имеет таких ограничений. Ограничения вводятся не по принципу «из-того-же-источника», а из «разрешенного-источника», и определяются не на клиенте, а на сервере. Думаю, внимательные уже заметили новый заголовок Origin. Через него передается информация откуда хотят подключиться к вашему websocket-у. Если этот адрес вас не устраивает, то вы отказываете в соединение.
			

		https://ru.wikipedia.org/wiki/WebSocket
		https://learn.javascript.ru/websockets
		https://blog.securityevaluators.com/websockets-not-bound-by-cors-does-this-mean-2e7819374acc

	- SSE API (server-side events) - события посылаемые сервером, т.е. однонаправленное HTTP-подключение к серверу.
		Ещё один вариант API, который предоставляет браузер для взаимодействия COMET. 
		Альтернатива WebSocket

  	- XMLHttpRequest (XHR) - объект, который дает возможность браузеру из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы.
		https://learn.javascript.ru/ajax-xmlhttprequest
		- Все современные браузеры (IE7+, Firefox, Chrome, Safari и Opera) имеют встроенный объект XMLHttpRequest.
		- Может работать с синхронными и асинхронными запросами
		- Как правило, XMLHttpRequest используют для загрузки данных.

	- Метод fetch - встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest.
		https://learn.javascript.ru/fetch
		Большинство браузеров уже поддерживает fetch – новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. 
		Он гораздо мощнее, чем httpGet. 
		Этот метод использует промисы. 
		Возвращает промис, который, когда получен ответ, выполняет коллбэки с объектом Response или с ошибкой, если запрос не удался.

	- DHTML (англ. Dynamic HTML) - совокупность технологий CSS, DOM и JavaScript


РАЗНОЕ
	- В React мы никогда не лезем в DOM напрямую. 
		Никаких getElementById и т.д. Мы работаем с VirtualDOm, а уже сам React занимается связкой Virtual DOM & DOM

	- Избегать циркулярных (циклических) зависимостей
		когда , например,  файл  a.js импортирует в себя файл b.js, и при этом внутри b,js есть импорт файла a.js. То есть фалы импортируются друг в друга. Это говнокод, идущий в разрез с принципами функционального программирования. Т.е не должно быть именно взаимных импортов. 
		Но, можно вызвать функцию из другого файла, и в качестве данных отдать в неё свою функцию. Т.е. использовать callback.
		https://www.youtube.com/watch?v=iN6QXbHedQc
	    
	- Как правильно получать данные из html-элемента (без использования ref)
		  let onQuoteChanged = (event) => {
		    let text = event.target.value;
		  };
		  return (
		        <textarea onChange={onQuoteChanged} />
		  }

	- Избегать изменения элементов/данных по ссылке 
		https://www.youtube.com/watch?v=NhT5nMvve4Q
		мы не знаем где ещё он используется. 
		работать надо с локальными переменными. 
		Никогда не менять внешние переменные, и тем более - ничего, что приходит в props. 
		Работать с иммутабельными данными (теми, которые не меняются по ссылке). Если нужно поменять что-то - мы не меняем по ссылке локальную переменную (например массив), а создаём новый массив с нужными параметрами

	  - Про JS-Объекты (и массивы). При копировании объект в памяти остаётся то же, на него просто создаётся новая ссылка. 
		  Поэтому, если измнеить что-то в объекте-копии, оригинальный объект тоже изменится (т.к. у нас есть только один объект, с двумя разными ссылками на него).
		  Если объект одноуровневый - можно сделать его полноценную копию так (через спред-оператор):
		  newObject = {...oldObject}
		  Но, если в объекте oldObject были вложенные объекты/массивы - они передадутся опять по ссылке, а не создадут полноценной копии.

	- При работе с функциями, мы передаём фактическую ссылку на функцию, а не строку.

	- Передача аргументов в обработчики событий
		https://ru.reactjs.org/docs/handling-events.html

		Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. 
		Например, если id — это идентификатор строки, можно использовать следующие варианты:

		<button onClick={(e) => this.deleteRow(id, e)}>Удалить строку</button>
		<button onClick={this.deleteRow.bind(this, id)}>Удалить строку</button>

		Две строки выше — эквивалентны, и используют стрелочные функции и Function.prototype.bind соответственно.

		В обоих случаях аргумент e, представляющий событие React, будет передан как второй аргумент после идентификатора. Используя стрелочную функцию, необходимо передавать аргумент явно, но с bind любые последующие аргументы передаются автоматически.


ООП 
	http://code.mu/books/javascript/oop/
	http://code.mu/books/php/oop/osnovy-raboty-s-objektno-orientirovannym-programmirovaniem-v-php-1.html

	Класс - абстрактное описание автомобиля. Чертёж
	Объект - конкретная реализация автомобиля
	Свойства - характеристики харакерные для всех машин. Количество колес, цвет, количество бензина... 
	Методы - команды, на котоыре может реагировать машина.	По сути функции, которые может вызывать каждый объект. 
	Геттеры и сеттеры - спец. методы, для добавления/получения свойств объекат (чтоб не использовать приватные свойста)

	S: Single Responsibility Principle (Принцип единственной ответственности)
		Каждый класс должен решать лишь одну задачу.

	O: Open-Closed Principle (Принцип открытости-закрытости).
		Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

	L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
		Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
		Классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

	I: Interface Segregation Principle (Принцип разделения интерфейса).
		Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. 
		Клиенты не должны зависеть от интерфейсов, которые они не используют.

	D: Dependency Inversion Principle (Принцип инверсии зависимостей).
	    Объектом зависимости должна быть абстракция, а не что-то конкретное.
    	Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
    	Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.


ОБЩЕЕ
	- React = функционально ориентированное программирование

	- React использует декларативный подход к программированию. 
		Описываем не поведение, а состояния компонентов (в зависимости от разных данных) + переключаемся между ними 

	- Среда React. Для работы используется:
		npm, 
		WebPack, 
		WebpAck server 
		специальная npm/yarn утилита Create React App. 
		OpenServer не нужен!

	- C Bootsrap можно работать как в чистом виде, так и при помощи специальных react-библиотек, которые интегрируют Bootstrap в React.

	- Создание приложения обычно выглядит так:
	  - есть некий дизайн (UI)
	  - глядя на него, я начинаю общаться с заказчиком, и разбираться - какие данный приходят на ту или иную страницу, какие с ними действия происходят, и т.д.
	  - на основе этого я формирую state для каждой из страниц. Формирую BLL - Busines Logic Layer
	  - параллельно решаю вопрос как управлять state (state managment)
	  - только потом начинаю кодить компоненты UI и связывать их со state

	- устанавливая пакет - дописывать в конце --save Означает, что нужно внести запись в package.json
		npm install react-router-dom --save

	- Отладка React
	    - React devtools поставляется в двух видах
	    	- отдельным пакетами
	    	- расширением для популярных браузеров. В расширении можно увидеть изменения состояний приложения и узлы виртуального DOM-дерева.
		- console.log()
			Иногда хочется отлаживать по старинке, с помощью console.log(). 
			Можно получить значение переменной внутри JSX прямо в точке её применения.
				<img src={console.log('logo', logo) || logo} />
			Как это работает: 
				console.log() вернет undefined и код выполнится дальше по условию "||", 
				а в консоли браузера мы увидим искомое значение, например: "/static/media/logo.5d5d9eef.svg".
		- (() => { debugger })() || // anything
		- Отладка внутри IDE WebStorm
			- Установите расширение Chrome — JetBrains IDE Support. 
			- Добавьте Run/Debug-конфигурацию.
			- Запустите create-react-app через терминал командой: $ yarn start
			- Выберите конфигурацию Debug и нажмите кнопку с иконкой жука (в правом верхнем углу IDE)
			- Откроется браузер с предупреждением "JetBrains IDE Support отлаживает этот браузер". Замечено, что если теперь открыть Chrome DevTools по [F12], то отладка в WebStorm завершится — не надо этого делать)
			-  можно отметить нужную строчку кода, как точку останова, затем перегрузить страницу браузера по [F5], и получить желаемое — инструмент отладки внутри WebStorm.


UX/UI
	UX дизайнер -  планирует то, как вы будете взаимодействовать с интерфейсом и какие шаги вам нужно предпринять
		когда изобретатель очередного точильного камня думал:
		    будет ли он сидеть и сам нажимать педаль
		    или он упростит механизм, но приставит раба который будет раскручивать колесо рукой,
		то в тот момент он был UX дизайнером.

	UI дизайнер - придумывает, как каждый из этих шагов будет выглядеть 
		Человек, который думал, какой величины будет камень, какого цвета выбрать дерево для подставки и чем скрепить деревянные жерди (гвоздями или кожаными жгутами?) и какой длины будет ручка, был UI дизайнером.

	И тот способ, каким бы вы затачивали меч — назывался бы интерфейс.
